'use strict';

///////////////////////////////////////
// Modal window

const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');

const openModal = function (e) {
  e.preventDefault();
  modal.classList.remove('hidden');
  overlay.classList.remove('hidden');
};

const closeModal = function () {
  modal.classList.add('hidden');
  overlay.classList.add('hidden');
};

btnsOpenModal.forEach(btn => btn.addEventListener('click', openModal));

// for (let i = 0; i < btnsOpenModal.length; i++)
//   btnsOpenModal[i].addEventListener('click', openModal);

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});

//making marketing platform for the Bankist App

//New lesson - How the DOM Really Works Behind the Scenes and Organized Internally

//The DOM is the interface between JS and the HTML documents rendered by the broswer. Working with web pages is working with the DOM - can create dynamic effects

//DOM allows us to make JS interact withthe browser. We can write JS to create, modify and delete HTML elements, set style, classes and attributes; and listen and respond to events
//The DOM tree is generated by an HTML document which we can then interact with

//DOM is a very complex API that contains lots of methods and properties to interact with the DOM tree (API = Application Progamming Interface -> the interface we can use to programaticcaly interact with the DOM)
//EX: .querySelector() / .addEventListener() / .createElement() / .innerHTML / .textContent /.children / ect..

//DOM has different types of nodes - some are HTML elements and others are just text - important to know bc all DOM methods and properties are organized into these different types of objects

//HOW is DOM organize dbehind the scenees - first every node in the DOM tree is of the type node. each node is represented by an object. This bject gets access tos epcial node methods and properties.

//Node type has some child types - element, text, comment and document types. So whenever there is text inside any element it gets its own text node. Same for HTML comments <!---->  For the element themself there is the element type of node which gives the html element access to many useful properties. Also useful methods.

//Each element is represented internally as an object. The element has internally an HTML element child type which also has one child type for each html element that exist in html --- so special type for buttons, links, images, ect. Each of these elements can have different unique properties like img getting a source attribute or anchor element has href attribute. DOM needs way of storing diff attributes so different types of HTML elements were created in the DOM API

//What makes this all work is inheritance - all the child types get access to the methods and properties of their parent node types --- so an html element will get access to everything from the element type (innerhtml, classlist, ect) besides that also gets access to eveything from the NODE tyhpe bc its also its parent type

//a DOM API is broken up into these different types of nodes and each of these types of nodes have access to different properties and m ethods and that some of them even inherit more properties and methods from their ancestors in the orginazational tree

//Document node type is another type of node that has important methods

//DOM API needs a way to let all node types listen to events, we usually do this by using addeventlistener - why does that work? bc there is a special node type called event target thats a parent of the node type and the window node type and so thanks to inheritcane we can call adeventlistener on every time of node in the API bc all the elemnets will inherit this method and be to add event listener on all of them just as if its there own method

//New LEsson - How to Select, Create and Delete Elements
//goal is to be quick reference in the future

//Select the entire document
console.log(document.documentElement); //this is what we need to select if we ever want CSS styles for an entire page

//select head
console.log(document.head);

//Select body
console.log(document.body);

//for these special elements we dont need a selector but otherwise we need one like querySelector

const header = document.querySelector('.header'); //this returns the FIRST element that matches this selector.

//For selecting multiple elements use querySelectorAll()
const allSections = document.querySelectorAll('section');

console.log(allSections); //This returns a node list containing all of the Elements that are a section (that are selected by the .section selector)

//these selectors are not only avaialbe on the document but also on the elements as well

//
document.getElementById('#section--1');
const allButtons = document.getElementsByTagName('button'); //this would give us all the buttons, or all the elements with the name of button
console.log(allButtons); //this shows all the buttons on the page. This method also returns an HTML collection which is diff from a node list bc its a live collection which means if the DOM changes this is updated automatically - so if we remove a button then it would delete 1 from the HTML collections -- we got this by the getElementsByTagName method

//same not true for a node list. edits made do not get reflected in the node list bc the variable was created by the time the section still existed and it was not updated upon the edit

//so the above is how we select elements

//Creating and inserting elements - we can create HTML elements using the adjacentHTML function like we used in the bankist application. Example below
document.getElementsByClassName('btn');

// .insertAdjacentHTML; //this retunrs also a live HTML collection //this is the most often used way of creating elements

const message = document.createElement('div'); //this will return a DOM element we can save somewhere. it is not yet in the DOM. if we want it on the page we have to insert it. First we will add classes
message.classList.add('cookie-message'); //this is going to add a class called cookie-message to the new div which can be used for further styling. now we will build an element to display a cookie message on the bottom of a screen

//we can add text into the element
message.textContent = `We use cookies for improved functionality and analytics.`;
//we can also insert HTML
message.innerHTML = `We use cookies for improved functionality and analytics. <button class="btn btn--close-cookie">Got it!</button>`;

//Now that we have the element we need to insert it into the DOM as shown below
header.prepend(message); //this inserts message into the header. So prepending as the element as the FIRST child of the element it is attached. If we want to add it to the last we can use append which will make it the last child and go to the bottom of the screen
header.append(message); //This moves it to the bottom but now it is gone from the top - it is not in two places bc the element message is a live element living in the DOM so it cant be at multiple places at the same time just like a person //append moves from first to last child. We can use prepend and append to insert elements and to move elements bc dom elements are unique so can only be one place at one time

//What if we want multiple copies of the same element? Would need to copy the first element

// header.append(message.cloneNode(true)); //thos gives us the same cookie node in both places - clone node true means all the child elements are also coppied. //usually we dont want this method tho so will cancel it out

//two more methods, before and after. before inserts the mssage before the element and after insets it after. Both of them as siblings.

// header.before(message); //this puts the cookies meessage above the header and the next one will put it after
header.after(message);

//so the above is to insert elements progamtically and now let us delete them as well -- we want to delete the Got it button when it gets clicked
document
  .querySelector('.btn--close-cookie')
  .addEventListener('click', function () {
    message.remove();
  }); //this removes the button!

//old way below:
// message.parentElement.removeChild(message);

//New LEsson - Styles, Attributes, and Classes
//we will keep working on the cookies message banner starting with styles

message.style.backgroundColor = '#37383d';
message.style.width = '120%'; //these styles get set inline so will take precedence

//can we read styles using these properties?
console.log(message.style.height); //gives nothing except for inline styles we set ourselves by using the style property - we did not manually set the height so nothing happens but if we try the same with background color it will tell us the rgb(55, 56, 61) because we have already defined that style
console.log(message.style.backgroundColor);

//We cant get a style hidden in a class or that does not exist
console.log(message.style.color);

//unless we use the getComputerStyle function
console.log(getComputedStyle(message)); //this prints a huge object containing all of the properties and values. Then we want to take a specific property from that huge object then we just apend on the property we want onto the back of the function as shown below

console.log(getComputedStyle(message).color);
console.log(getComputedStyle(message).height); //even tho we didnt define it the browser needed to callc to dislay it and so we are given that value

//what if we want to increase the number of the message banner by 40px? first get its current height using this method and than add on 40px

message.style.height = getComputedStyle(message).height + 40 + 'px'; //so this is a string except for the number so we are trying to add a # to a string which wont work which is why nothing returns to the console. However we can use the parse function to remove the number from the string as shown below

message.style.height =
  Number.parseFloat(getComputedStyle(message).height, 10) + 30 + 'px';

//css variables can be changed from JS :root is equal to the document element
// document.documentElement.style.setProperty('--color-primary', 'orangered'); //this has changed the color of color primary from what it is set to in the css fie to orange red as specified here so now anywhere with color-primary will be orange red

//so with variables must use setProperty and pass in the name of the property you want to change and the value you want to change it to

//what about attributes? src, alt, class, id, ect of HTML elements. we can access and change. ex we will select the logo
const logo = document.querySelector('.nav__logo');
console.log(logo.alt); //this gives us the alternative text
console.log(logo.src); //this gives us timg source
//only standard properties work like this.
console.log(logo.className);

//Non-standard
console.log(logo.designer);
console.log(logo.getAttribute('designer')); //this will return the non standard property values

//we can set these values as well
logo.alt = `Beautiful minamilist logo`;

//also have setAttribute
logo.setAttribute('company', 'Bankist'); //this creates a new attribute
console.log(logo.src); //the source shown here is diff from HTML bc this HTML in log is the absolute url while in the index.html is the relative url relative the the fodlder in which the html file is located. If ypou want the relative file you must also you get attribute
console.log(logo.getAttribute('src')); //this gives the relative address img/logo.png instead of the absolute http://127.0.0.q:5500/img/logo.png

//same true for href attribute on links
const link = document.querySelector('.nav__link--btn');

console.log(link.href);
console.log(link.getAttribute('href'));

//Data attributes
//start with the word data - we will add one to our img data-version-number='3.0'
console.log(logo.dataset.versionNumber);
//data attributes common for saving data into the UI - in the HTML code

//Classes -
logo.classList.add('c', 'j');
logo.classList.remove('c', 'j');
logo.classList.toggle('c');
logo.classList.contains('c');

logo.className = 'jonas'; //dont use this

//New Lessonn - Implementing Smooth Scrolling
//this is how to implement smooth scrolling!!!

//old school method
//start by selecting the button and section we want to scroll to, in this example btn--scroll-to to #section-1
const btnScrollTo = document.querySelector('.btn--scroll-to');
const section1 = document.querySelector('#section--1');

//now add event listener to the button
btnScrollTo.addEventListener('click', function (e) {
  //first we need the corrdinates of the element we want to scroll to
  const s1coords = section1.getBoundingClientRect();
  console.log(s1coords);

  console.log(e.target.getBoundingClientRect());

  console.log('Current scroll (X/Y)', window.pageXOffset, window.pageYOffset);
  //these three methods give us coordinates to learn the height
  console.log('height/width viewport', document.documentElement.clientHeight);
  console.log('height/width viewport', document.documentElement.clientWidth);

  //we need the corrdinates to tell JS where to scroll to
  //SCROLLING
  // window.scrollTo(
  //   s1coords.left + window.pageXoffset,
  //   s1coords.top + window.pageYOffset
  // );

  // window.scrollTo({
  //   left: s1coords.left + window.pageXoffset,
  //   top: s1coords.top + window.pageYOffset,
  //   behavior: 'smooth',
  // });

  //Modern way
  //take element we want to scroll to and on that call scrollintoview and on that call in an object and specifiy smooth
  section1.scrollIntoView({ behavior: 'smooth' });
});

//New Lesson - Types of Events and Event Handlers
//events are signals generated by a certain DOM node - lick a click or mouse moving or user triggering full-screen mode or any important things really generate events and we can listen for thos vents to handle them if we would like.

// const h1 = document.querySelector('h1');

// h1.addEventListener('mouseenter', function (e) {
//   //mouse enter is like hover - it fires when the mouse enters an area
//   // alert(`add event listener: great! you are reading the heading`);
// });

// //anither way ofg attaching an event listener to an element is below
// h1.onmouseenter = function (e) {
//   // alert(`same shit as above!~`) //this way of listening is old school now we use addevenetlistener
// };

//addeventListerner allows multiple event listeners to the same event but onmouseenter the last function would override the preceeding.

//also we can remove an event handler if we dont need it anymore   HOW? First export the function to a named functin

// const alertH1 = function (e) {
//   alert(`blah blah blah`);

//   h1.removeEventListener('mouseenter', alertH1); //this makes it so the event only happens once (prevents repopping up al the time)
// };
// h1.addEventListener('mouseenter', alertH1);

// //you can remove event listeners after time hhas passed as well
// setTimeout(() => h1.removeEventListener('mousedown', alertH1), 3000);

//third way of handeling events is using an HTML attribute and should not be used.

//New LEsson - Event Propogation: Bubbling and Capturing
//JS events have a capturing and bubbling phase.

//if a click happens on a link the DOM click event is not generated at the target element (where the event happened - click on the lini) instead the evvent is generated at the root of the document. From there the capturing phase happens where the event travels from the document root to the target element. As the event passes down the tree it passes through every parent element of the target element until it reaches its target - when the event reaches the target the target phase begins where events can be handled right at the target with event listeners.

//event listeners wait for a certain event to happen and when it occurs it runs the attached callback function - after reaching the target the event travels all the way up to the document root again in the bubbling phase passing through all parent elements on the way to the Document root. So this means it is like the event happened in each of the parent elements too

//This means if we attach the same event listener to the section element we woud get the same alert window - so we would have handeled the event twice which allows us to implement powerful patterns

//by default events can only be handled in the target and bubbling phase but we can set up event listeners to listen durng capturng phase instead

//not all types of events have capturing and bubbling phase - some ARE created on the target element and can only be handled there but most events capture and bubble - they propogate.

//New Lesson - Event Propagation in Practice
//we are going to attach event handlers to the navigation link and all of its parent elements. Then as we click the link we will give all the elements rndm background colors so we can visualize exactly how event bubbling occurs

//tart by making random color - a string rgba and coolor betwen 0 and 255
const randomInt = (min, max) =>
  Math.floor(Math.random() * (max - min + 1) + min);

const randomColor = () =>
  `rgba(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`;
console.log(randomColor(0, 255));

//now attach event handlers
// document.querySelector('.nav__link').addEventListener('click', function (e) {
//   this.style.backgroundColor = randomColor();
//   console.log('LINK', e.target, e.currentTarget); ///target is where the event first happened
//   console.log(e.currentTarget === this); //gives true

//   e.stopPropagation(); //this stops the propogation so now click events are limited to the link and do not bubble up to the parents
// });
// document.querySelector('.nav__links').addEventListener('click', function (e) {
//   this.style.backgroundColor = randomColor();
//   console.log('CONTAINER', e.target, e.currentTarget);
// });
// document.querySelector('.nav').addEventListener('click', function (e) {
//   this.style.backgroundColor = randomColor();
//   console.log('NAV', e.target, e.currentTarget); // this results in raqndom colors being generated by each layer of the element from the features link to the nav links to the entire navbar
// });
//in all 3 handlers the target was alaways the same bc that is the element where the click firs thappened and it occurs in all three handlers bc all three are involved in the same event due to event bubblinb. it originates in the link but then bubbles up to its parent and then that parents parent up the DOM tree - so we can handle it in all the parent elements

//besides target also hae current target - current target is the same as the this keyword bc the this keyword also points to the element the event handler is attached too

//we can also stop event propogation by calling on the event e.stopPropogation();   generally not good practice but can sometimes work in complex applications

//so the 3 eventhandlers we set up recieve events from the target elements and also from the bubbling phase - the event handler functions ar elistening to lcick events on the element itself

//What about capture phase? Events are captured when they come down the document root to the target but our events are not picking up the events during the capture phase. Addeventlistener is only listening during bubbling phse - that is default for addeventlistener method bc capturing phase is usually irrelevant wheras bubbling very useful for event delegation

//however if we want to catch events we can define a 3rd parameter in the addeventhandler function - we can set it to true or false

// document.querySelector('.nav').addEventListener(
//   'click',
//   function (e) {
//     this.style.backgroundColor = randomColor();
//     console.log('LINK', e.target, e.currentTarget);
//     console.log('NAV', e.target, e.currentTarget);
//   },
//   false
// ); //this case the eventhandler will no longer listening to bubbling events, but to capture events, which looks the same here but in the log the NAV gets called first bc that element is listening for the event at ist travels down the DOM while the others are listening for events when they travel back UP - so first events travel down so this is the first place the event gets logged in capturing. By default is set as false/. C apturing is rarely used. They only exist for historical reasons really.

//important take away is why the three boxes get three different background colors even though the click only happened on the one button.

//NEw Lesson - Event Delegation: Implementing PAge Navigation
//we will implement smooth scrolling in the navigation so that when we click a link it will scroll us smoothly to that section

////////////////////////
//PAGE NAVIGATION
// document.querySelectorAll('.nav__link').forEach(function (el) {
//   el.addEventListener('click',

//   function (e) {
//     e.preventDefault();
//     const id = this.getAttribute('href');
//     console.log(id);
//     document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
//   });
// });
//the above is the old way but not good for use with many elements bc it creates copy for each element which effects performance - so best method for implemeneting scroll is event delegation which uses fact that events bubble up and put the event listener on a common parrent of all the elements we are interest in - in our example the container that is around all of the navigation lines (class="nav__links") then when a user clicks one of the links the event is generated and bubbles up

//We can catch the event i the parent element and handle it there bc we know where the event originated by looking at events.target

//Event delegation needs two steps 1) we add the event listener to a common parent element of all the elements we are interested in (nav__links)    2) in that event listener determine what element originated the event so we can then work with that element where the event was created

document.querySelector('.nav__links').addEventListener('click', function (e) {
  console.log(e.target);

  if (e.target.classList.contains('nav__link')) {
    e.preventDefault();
    const id = e.target.getAttribute('href');
    console.log(id);
    document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
  }
}); //we need a matc hing strategy to match only the elements we are interested in - best way is to check the target class (this example uses nav__links)
//now we only selected the link elements

//Event delegation also good for working with elements not yet on the age at run time like buttons added dynamically while usng the pplication --- cant add event handlers on elements that dont exist but can still handle events on elements that dont exist at the beginning by usig event delegation

//New Lesson - DOM Traversing
//this means walking through the DOM which means we can select an element based on another element - this is important bc sometimes we need to select elements RELATIVE to other elments for example a direct child or direct parent element - sometimes we dont know the structure of the DOM at run time so in all these cases we need DOM traversing

//starting with the h1 element when banking meets minimalist
const h1 = document.querySelector('h1');

//going down downwards and selecting child elements
//1st method uses query slector bc this method works on elements not only the document
console.log(h1.querySelectorAll('.highlight'));
//this gives us the elements with the highlight class that are children of the h1 element. this would work no matter how deep the elements are inside h1

//for direct children
console.log(h1.childNodes); //gives a nodelist with 9 instead of two. nodes can be text or elements or comments. It gives us all the nodes and all the types that exist but many times we aare only interested in the elements themselves so childnodes not that used but can also use children which gives us an HTML collection which is a live collection containing only the 3 elements INSIDE of the h1
console.log(h1.children); //this one only works for direct children

//also first and last element child
// h1.firstElementChild.style.color = 'white'; //this changes the first child which is the banking highlighted word

// h1.lastElementChild.style.color = 'purple'; //this changed minimalist

//Now lets go upwards! Slecting parents
//For direct parents
console.log(h1.parentNode); //This gives the div with class="header__title"

//also have parent element which is same in this case
console.log(h1.parentElement);

//oftentimes we need a parent element no matter how far it is inn the DOM tree and so we have the closest method. ex// we have mutliple headers but we only want the one that is a parent element of our h1 here - for that we can use closest which receives a query string
// h1.closest('.header').style.background = 'var(--gradient-secondary)'; //this changes the entire header, which si the direct parent of the h1, to the gradient secondary color. It selected the closest parent element with header class and applied that style

//if the selector matches the element in which we are calling closest then thats the elemnt that will be returned
// h1.closest('h1').style.background = 'var(--gradient-primary)'; //

//queryselector finds children no matter how deep in the DOM while closest finds parents no matter how far up

//Going sideways! selecting siblings baby! can only access direct siblings - previous and next one
console.log(h1.previousElementSibling); //null bc this is the first child so it doesnt have a previous sibling but it does have a future one which is shown
console.log(h1.nextElementSibling);

console.log(h1.previousSibling);
console.log(h1.nextSibling); //gives answers as text now most of the time we work with elements

//if we need all elements then move up to parent elemennt and read all children from there
console.log(h1.parentElement.children);
// [...h1.parentElement.children].forEach(function (el) {
//   //we want to do something to all the siblngs but not the element itself
//   if (el !== h1) el.style.transform = 'scale(0.5';
// });

//New Lesson - Building a Tabbed Component
//tabbed components on many websites so lets see how to build - this is the third section of the website which has tabs and when the tabs are clicked the content below the tabs changes -- each tab has its own content area

//hw to implement? first need HTML - the whole tabbed component is the div class="operations" - then is the tab-container which is the element that contains the three tabs which are all buttons with the class operations__tab. Below that are the 3 contents - 1 for each tab (operations__content--1,--2,--3)

//so when we click on a tab we will not create any new content instead we will hide the other tabs - only the one being shown will have the --active class aplied to it making it visible. Also the buttons have a data-tab attribute which is associated with the class name --1,--2.--3.

//LEts build the tabbed component///////////////////////
///////////////////////////////////////////////////////
const tabsContainer = document.querySelector('.operations__tab-container');
const tabs = document.querySelectorAll('.operations__tab');
const tabsContent = document.querySelectorAll('.operations__content'); //these are the 3 selections we need to work on functionality

// tabs.forEach(tab =>
//   tab.addEventListener('click', () => console.log('TAB WORKS'))
// ); //this works, however, doing this is bad practice bc what if we had 200 tabs? Then would have 200 copies of this exact function - so dont do it! Use event delegation instead!

//Remember for event delegation we have to attach the event handler on the common parent element of all the elements we are interested in which in this case is the tabs container which is where the 3 buttons are contained!

//So we will attach our event handler to that element instead
tabsContainer.addEventListener('click', function (e) {
  //we need the event so we know where the click happened. Lets work on matching strategy:  we already know we are interested in the buttons and now we need to know which button was clicked. We will create an element called click that we can then use to work with
  const clicked = e.target.closest('.operations__tab');
  console.log(clicked); //this now tells me which tab --1,--2, or --3 was clicked but there is a problem when we click on the number - we get the span element! That is because inside the button we have the span element inside it so we end up clicking on the span not the button ---- how can we make it so that whichever we click, the span or button, the button element is selected.

  //from the button element we need to read the data-tab attribute tab bc that contains the number of the tab that should become visible and so this data attribute is important for storing information inside the DOM  data-tab="1","2","3"

  //We need a way of finding the button element whenever we click on the span element -we need a way of selecting the parent element that is always the tab - what method does this? CLOSEST method, very helpful in event delegation. Add this edit onto const clicked = e.target.closest('.operations__tab')   this will search for the closest operations tab, which of course will be the one clicked!

  //Guard clause
  if (!clicked) return; //this statement returns early if its condition is matched (there is nothing clicked). in this case when we have null which is a falsy value, then not falsy becomes true and the function will return and none of the code after will be executed. If click does exist then return will not be executed and the rest will be just fine.
  //same as if(clicked) { clicked.classList.add('operations__tab--active) but it is more modern}
  //so whenever there is no clicked element we want to return the function right away so the other code is not executed //we still get null value when we click near the tabs but no error anymore bc JS is no longer trying to execute the line of code below

  //what about making the buttons that are not clicked gfo down --- removing the active class? Go to bottom below ABOVE clicked.classList.add...
  tabs.forEach(tab => tab.classList.remove('operations__tab--active')); //this will remove the active state from all tabs so the tabs move up and down as supposed to. So clearing the class for all then adding it back to one.

  //it works!

  tabsContent.forEach(content =>
    content.classList.remove('operations__content--active')
  );

  //now we need to make the active state apply to the tab that gets selected
  clicked.classList.add('operations__tab--active'); //this makes the clicked tabs active but the tabs dont move back down
  //if we click in the tabs container at this point, outside the tabs, we get cannot read classlist of null --- null is the result of the closest method when there is no matching parent element to be found and when we click into the tabs container there is no parent with that class name so we get null. NEed to fix this and ignore any clicks that happen in that area to make the result null

  //We will insert a guard clause ABOVE clicked.classList.add('operations__tab--active)

  //removeing the active state-- before we add the class to anyone we remove it from everyone! So we will do this above clicked.classList.add('opeations__tab--active) but below if(!clicked) return;

  //Now finally lets activate the content area!/////////////
  ///////////////////////////////////////////////////
  //The data attribute tells us which content area we want --- so data-tab 2 goes with the content box with class operations__centent--2
  document
    .querySelector(`.operations__content--${clicked.dataset.tab}`)
    .classList.add('operations__content--active'); //remember the attributed (Data-tab) are in the element and in the data set property- so the element that is clicked get stored in our variable clicked. So everytime we click a button that click is stored in the click variable so then can use ${clicked.dateset.tab} - this gives us the part after the data (1, 2, or 3) and so it is selected. Now that it is selected we want to add a class to it so its content will get displayed

  //this works to display the content upon button clicks but now each content is displayed in column and will not go away. So now need to do again like we did for the tabs by removing the active class to all of them before adding it to the one we are interested in - so we will edit the tabs.forEach(tabs => tabs.classlist....) by selecting all the contents (tabsContent) which is also a nodelist bc of query selectorall that we can loop over and remve the active class from all   tabsContent.forEach(cpntent => content.classList.remove('operations__content--active))
});

//New Lesson - Passing Arguments to Event Handlers
//Example - when we hover one of the nav links we want the others to fade out a bit. So we will be working with the nav__link(s)

//MENU FADE ANIMATION//////////
/////////////////////////////////////////////////
//Use event delegation - find the common parrent elemet of all the links and logo so the parent container is nav class="nav"
const nav = document.querySelector('.nav'); //mouseenter does not bubble, mouseover does. mouseleave and mouseout are opposite coommands
nav.addEventListener('mouseover', function (e) {
  //we need to match the element we are looking for which is elements with the nav__link class on them
  if (e.target.classList.contains('nav__link')) {
    //this time we did not use closest because there are no child elements like spans that we can click inside the link as before
    const link = e.target; //creating a variable containing the element we are working with. Now we eed to select the sibling elements -- all the other elements -- by going to the parent then selecting the children. The parent of nav__link is nav__item and nav__item only includes 1 link. So each link is inside 1 nav__item so we need to move up twice - so we will use closest method which searches for a parent matching a certain query
    const siblings = link.closest('.nav').querySelectorAll('.nav__link'); //so .nav is the parent for all of the links and so on there we will use queryselector to search for the navlinks which are the siblings of our initial links.(looking for nav__link). Now we will select the logo too - we could do manually by classname but assuming many navigations on the page we will just use event delegation again by moving up to the closest parent and from there search for the img(logo) - now this works on this navigation and others as well
    const logo = link.closest('.nav').querySelector('img'); //this will select for any image with the image tag

    //Now that all elements are selected need to change the opacity of the siblings of the selected link

    siblings.forEach(element => {
      if (element !== link) element.style.opacity = 0.5;
    });
    logo.style.opacity = 0.5; //this works so that when you hover a link the rest transition but the transitions do not leave when the hovering is stopped - will not autmoatically go back - this is what mouseout is used for
  }
});
nav.addEventListener('mouseover', function (e) {
  if (e.target.classList.contains('nav__link')) {
    const link = e.target;
    const siblings = link.closest('.nav').querySelectorAll('.nav__link');
    const logo = link.closest('.nav').querySelector('img');
    siblings.forEach(element => {
      if (element !== link) element.style.opacity = 0.5;
    });
    logo.style.opacity = 0.5;
  }
});

nav.addEventListener('mouseout', function (e) {
  if (e.target.classList.contains('nav__link')) {
    const link = e.target;
    const siblings = link.closest('.nav').querySelectorAll('.nav__link');
    const logo = link.closest('.nav').querySelector('img');
    siblings.forEach(el => {
      if (el !== link) el.style.opacity = 1;
    });
    logo.style.opacity = 1;
  }
}); //the above code block removes the hover effect for the nav links upon mouseout

//Both the above two blocks are very similar so we will refactor them both below:
const handleHover = function (e) {
  if (e.target.classList.contains('nav__link')) {
    const link = e.target;
    const siblings = link.closest('.nav').querySelectorAll('.nav__link');
    const logo = link.closest('.nav').querySelector('img');
    siblings.forEach(element => {
      if (element !== link) element.style.opacity = this;
    });
    logo.style.opacity = this; //ths keyword comes from the bind method which made a copy of the function -this = 1 and this = .5
  }
};
//now how do we use this refactored function?

// nav.addEventListener('mouseover', function (e) {
//   //usually when we have the event handler as a seperate function we pass in that function: nav.addEventListener('mouseout', handlehover);    but we want to pass values into the handlehover function, we need to tell it about opacity, we also need to pass the event. If we tried to do it like this it would fail bc e is not defined and the addeventlistener expects a function --- but if we call the function then that becomes another value, not a function. nav.addEventListener('mouseout', handlehover(e, 0.5));  that wont work. Solution is to have a callback function which JS calls for us when the event happens and then inside that we call the handlehover function with thte event and opacity

//   //nav.addEventListener('mouseout', function (e) {
//     //handleHover(e, 0.5) this works bc here we are passing in a real function
//   // });

// });
// });

nav.addEventListener('mouseover', function (e) {
  handleHover(e, 0.5);
});
nav.addEventListener('mouseout', function (e) {
  handleHover(e, 1);
});
//this makes it work

//Want to be cleaner? okay... USe bind method. bind method creates a copy of the function in which it is called and it sets the this keyword in this function call to whatever value we pass into bind
nav.addEventListener('mouseover', handleHover.bind(0.5));
nav.addEventListener('mouseout', handleHover.bind(1)); //this also works because bind(#) is a function which returns a new function. In this function the this variable will be set to the values spcieied .5 and 1

//usually this keyword is equal to currentTarget. by default the this keyword is the same as currenttarget - i.e. the element the event listener is attached. When we set manual is what we set it to tho

//Now we can use the this keyword inplace of = opacity because the this keyword is now opacity. the bind method passed an argument into a handler function

//it is impossible to pass another argument into an event handler function - it can only ever have one real argument - if we want to pass additional values into the handler function then we need the this keyword and if we want multiple values then can pass in an array or object into bind instead of one value

//this is a workaround to the fact handler functions can only take a single argument

//New Lesson - Implementing a Sticky Navigation: The Scroll Event
//common feature when the navigation bar becomes attached to the top of the page once we scroll past a certain point - this is aka 'sticky navigation.'

//we make the nqavigation sticky by adding the sticky class whenever we reach a certain position -- sticky changes position to fix and back-color

//STIKY NAVIGATION
///////////////////////////////////////////
// const initialCoords = section1.getBoundingClientRect();
// console.log(initialCoords); //this gives us the starting top value of the section which we can work withh

// //scroll event is one method to di shown below
// window.addEventListener('scroll', function () {
//   // console.log(e); //this even gets fired off each time we scroll on our page - so the scroll event is not very efficient and should be avoided but for now we will use it
//   console.log(window.scrollY); //this will give us the scroll position on the window object - gives us position from the point at the viewport to the top at the page

//   //navigation should become sticky at boundary of first section but we canot hardcode it- must be calculated dynamically. Have to determine the position of the first section

//   if (window.scrollY > initialCoords.top) nav.classList.add('sticky');
//   else nav.classList.remove('sticky');
// });
//the above is poor practice bc performance is bad bc using the scrollevent for performing a certain action at a certain position is not the way to go bc the scroll event fires ALL the time which makes bad performance, especially on mobile.

//New Lesson - A Better Way: The Intersection Observer API
//Now we will do the same sticky navigation but this time using the new intersection observer API which allows our code to observe changes to the way a certain target element intersects another element or the viewport.

//how does the intersection observer API work????? To use it we need to start by creating a new intersection observer and inside we ave to pass in a callback function and an object of options
// const obsCallback = function (entries, observer) {
//   entries.forEach(entry => {
//     console.log(entry); //this gives us an IntersectionObserverEntry
//   });
//this will get called each time the target element interesects the root element at the threshold we defined. //so in this example whenever the first section(our target) is intersecting the viewport at 10% (viewport is the root and 10% bc that is the threshold) then the obsCallback function gets called whether we are scrolling up or down

//the function is called with two arguments: entries, observer. Thresholds can be multiple, or an array

//when we scroll down our target element starts intersecting the viewport which triggers an IntersectionObservationEntry which our observer is observing.  Now we can see the intersectionRatio at the time the callback was called is .100 which is the 10% threshold we defined below

//we also get isIntersecting set to true because our target is intersecting the viewport and we are looking for the viewport bc we set the root to null

//whether you scroll down or up you get a new IntersectionObservationEntry - this method is more efficient bc we only get the event in the situation we are actually interested in which is within threshold not any and every event on the page, mostly non releeant
// };

// const obsOptions = {
//   root: null,
//   threshold: [0,0.2], //the root is the element that the target is intercepting (target is section 1 in this ex) - we want section 1 to itersect our root element/ null lets us observe the target element intersecting the entire viewport
//threshold is the % of intersection at which the observer callback will be called
//[] 0% means our callback will trigger each time the target element moves completely out of the view and as soon as it enters the view
// };

// const observer = new IntersectionObserver(obsCallback, obsOptions);
// //now we use that observer to observe a certain target
// observer.observe(section1);

//When do we want our navigation to become sticky? When the header moves completely out of view. So this time we will observe the header element

//sticky nav
const headerx = document.querySelector('.header');

const navHeight = nav.getBoundingClientRect().height;
console.log(navHeight);

const stickyNav = function (entries) {
  const [entry] = entries;
  // console.log(entry);

  if (!entry.isIntersecting) nav.classList.add('sticky');
  else nav.classList.remove('sticky');
  //now create logic for adding and removing the classes. We are interested in isIntersecting. Only when the header is not intersecting the viewport is when we want to aadd the sticky class
};

const headerObserver = new IntersectionObserver(stickyNav, {
  root: null,
  threshold: 0,
  rootMargin: `-${navHeight}px`, //this sets where the navigation appears before or after the threshold!
});
headerObserver.observe(headerx);

//not done yet - implement navigation coming into specific spot - use rootMArgin: 90  == 90px applied utside our target element

//New Lesson - Revealing Elements on Scroll
//this also uses the intersection observer api. this time we will reveal elements once we scroll close to them
//1) first apply the hidden class to all the sections you want it to apply to - do this in the HTML. Now we need to remove that class as we approach each section

//REVEAL SECTIONS BB!
const allSectionss = document.querySelectorAll('.section');

const revealSection = function (entries, observer) {
  const [entry] = entries;
  // console.log(entry);
  if (!entry.isIntersecting) return;
  entry.target.classList.remove('section--hidden');
  observer.unobserve(entry.target);
};

const sectionObserver = new IntersectionObserver(revealSection, {
  root: null,
  threshold: 0.15,
});

allSectionss.forEach(function (section) {
  sectionObserver.observe(section);
  // section.classList.add('section--hidden');
});
//We want to observe all 4 sections in this case and its possible to observe them using the same observer. First selct all the sections then we will oserve them as mutiple targets using this observer we created

//New Lesson - Lazy Loading Images
//images have biggest impact on page loading so important to optimize images - best to use lazy loading which is a good strategy to do this

//effect is that images only load when the page is being scrolled - not all loaded at once - in HTML this is implememnted by using a very low resolution image that is added when the page loads and then a higher resolution  - heck features img attributes.

//As we scroll to the lower reso img we replace it with the higher reso img and we also remove the lazy-img class which removes the blur on the img using a filter blur 20px. the lazy load images will have the data-src attribute in the html

//impleet using intersectionObserver

//LAZY LOADING IMAGES SO IMPORTANTTTT AHGHHWDEJIFKDFSKDK!!!!
const imgTargets = document.querySelectorAll('img[data-src');
console.log(imgTargets);

const loadImg = function (entries, observer) {
  const [entry] = entries;
  console.log(entry);

  if (!entry.isIntersecting) return;
  //replace src with data-src -- this replaces the low res with the high res img
  entry.target.src = entry.target.dataset.src;

  entry.target.addEventListener('load', function () {
    entry.target.classList.remove('lazy-img');
  });

  observer.unobserve(entry.target); //this will unobserve the images
};

const imgObserver = new IntersectionObserver(loadImg, {
  root: null,
  threshold: 0,
  rootMargin: '200px',
});

imgTargets.forEach(img => imgObserver.observe(img));

//stop observing the images bc no longer necessary observer.unobserve(entry.tarfet)           this video shows you how to implement the functionality by generating place holder images then blur them and then implement this logic . we dont want users to know we use lazy loading all the time so we can specify root margin to speed up the load times - so exctly 200px before any of the img are loaded it should start loading so we dont see a delay

//New LEsson -- Building a Slider Component
////slider component in HTML contains 3 slides which are all side by side. transform: translateX() used to shift slides during button clicks --adapt the %'s as we go!

//SLIDER
//////////////////////////////////////////////////////
//Slider component contains 3 slides side by side in the HTML. The slides move by usng transform: translateX. Width of each slide is 100. We need to adapt the start positions as we change the positions (0 100 200)

//our sides on top of eachother currently so we need to establish the condition where they are side by side --- we will do this by setting the transform property

//content inside the slides irrelevant - we only care about the slide(s) inside the slider
const slider = function () {
  const slides = document.querySelectorAll('.slide');
  let curSlide = 0;
  const maxSlide = slides.length;

  //slide 1 at 0-100, slide 2 at 100-200, slide 3 at 200-300% - above code puts slides side by side. observer has been hidden. To better see the slider we can change the size and see the slides using code block below:
  // const slider = document.querySelector('.slider');
  // slider.style.transform = 'scale(0.5) translateX(-300px)';
  // slider.style.overflow = 'visible'; //this is all removed when done editing

  ////Make the slider work below
  const btnLeft = document.querySelector('.slider__btn--left');
  const btnRight = document.querySelector('.slider__btn--right');
  const dotContainer = document.querySelector('.dots');

  const createDots = function () {
    slides.forEach(function (_, i) {
      dotContainer.insertAdjacentHTML(
        'beforeend',
        `<button class="dots__dot" data-slide="${i}"></button>`
      );
    });
  };

  const activateDot = function (slide) {
    document
      .querySelectorAll('.dots__dot')
      .forEach(dot => dot.classList.remove('dots__dot--active'));

    document
      .querySelector(`.dots__dot[data-slide="${slide}"]`)
      .classList.add('dots__dot--active');
  };

  const goToSlide = function (slide) {
    slides.forEach(
      (s, i) => (s.style.transform = `translateX(${100 * (i - slide)}%)`)
    );
  };

  const nextSlide = function () {
    if (curSlide === maxSlide - 1) {
      curSlide = 0;
    } else {
      curSlide++;
    }
    goToSlide(curSlide);
    activateDot(curSlide);
  };

  const prevSlide = function () {
    if (curSlide === 0) {
      curSlide = maxSlide - 1;
    } else {
      curSlide--;
    }
    goToSlide(curSlide);
    activateDot(curSlide);
  };

  const init = function () {
    createDots();
    activateDot(0);
    goToSlide(0);
  };

  init();

  //Event handlers
  btnRight.addEventListener('click', nextSlide);
  btnLeft.addEventListener('click', prevSlide);

  document.addEventListener('keydown', function (e) {
    // console.log(e);
    if (e.key === 'ArrowLeft') prevSlide();
    e.key === 'ArrowRight' && nextSlide();
  });

  dotContainer.addEventListener('click', function (e) {
    if (e.target.classList.contains('dots__dot')) {
      // console.log(`log`);
      const { slide } = e.target.dataset;
      goToSlide(slide); //this code block makes the dots change the slides
      activateDot(slide);
    }
  });
};
slider();

//Next Lesson - Lifecycle DOM Events
//lifecycle is the moment the page is 1st accessed until user leaves

//1)DOM content loaded - this event fired by doc as soon as HTML completely parsed (downloaded and converted to DOM tree) - all scripts must be downloaded and executed before the DOM content loaded event can happen.

//We can listen to that event like below:
document.addEventListener('DOMContentLoaded', function (e) {
  //this even does not wait for images or external resources, just HTML and JS need to be loaded
  console.log('HTML parsed and DOM tree built', e); //this can execute code that should only be executed after the DOM is available.

  //when the script tag is at the bottom of the page we dont need to listen for toe DOMContentLoaded event
});

//the load event is fired from the window when the html and images and external resources like css files are loaded - then this event gets fired. The load event.
window.addEventListener('load', function (e) {
  console.log('page fully loaded', e);
});

//before unload event - also gets fired on window
window.addEventListener('beforeunload', function (e) {
  e.preventDefault();
  console.log(e);
  e.returnValue = '';
}); //this event gets created right before a user leaves a page, like after clicking the close button - we can use this event to ask users if they are 100% they want to leave the page!!!!****** obtrusive message - use if user is in middle of filling out a form or ding something important and tries to leave during

//New Lesson - Efficient Script Loading: defer and async
//to this point we always include js files using the script tag as normal but we can also add the async or defer attributes to the script tag which effects how the js file gets downloaded and executed

//in HTML can write script at head or end of body. We will compare both situations here

//When we include a script without any attribute in the head, what will the load process look like over time? As user loads page and recieves HTML the code starts to get parsed by the browser which is buiolding the DOM tree - at some point will find our script tag, start to fetch the script and then execute it. During this tie the HTML parsing stops as it waits for the script to be fetched and executed. After that the other HTML can be parsed and at the end the DOMContentLoading event will finally get fired. ----This is not ideal. We dont want the browser sitting there doing nothing as it impacts page poorly and the script gets executed before the DOM is ready which is not ideal ---- TAKE AWAY? NEVER PUT THE SCRIPT IN THE HEAD

//the regular load when the script on the end loads like this: the HTML is parsed then the script tag is found at the end of the document then the script is fetched and finallly executed --- much better practice. This is why we put the script at the end of the body. Still not perfect tho bc script could have been downloaded before while the HTML was stil be ing parsed

//What if we use the async attribute in the script tag? In the head of the docuent the script is loaded at the same time the HTML is parsed, however the HTML parsing still stops for the script execution - so the script is downloaded asncyrnously  but then is excuted syncronously so the HTML has to wait to finish being parsed. This is still a shorter page load than the first two

//What about the defer attribute? In deferring the script is still loaded asyncronously but the execution of the script is deferred until the end of the HTML parsing - HTML parsing is NEVER interuppted. MAny times this is what we want. IN THE HEAD!!!!

//Async and Defer DONT MAKE SENSE to go in the body bc in the body fetching and executing always happens afte rpasng HTML so async and defer have no effect there.

//What are the use cases for these strategies? Except direct loading in the head which you should never do.

//Strategy 1 - putting the script at the end of the body:
//Strategy 2 - Using a script tag with async attribute in the head
//Strategy 3 - Using a script tag with defer attribute in the head

//async loaded scripts - the DomContentLoaded event doesnt wait on the script t be downloaded and executed --- usually it does but scripts loaded with async are an exception. DSo the DomContentLoaded gets fired off as soon as the HTML finishes parsing - this might happen when a big script takes a long time to load.

//Using defere forces the  DomContentLoaded event to only be fired after the whole script has been downloaded and executed.

//async scripts are not gaurenteed to be executed in the otder put in the code - the script that arrives first gets executed first - using defer guarentees the scripts are executed as they are written in the code - this is usually what we want to happen

//USING DEFER IN THE HTML HEAD IS OVERALL THE BEST SOLUTION - so use this for own sripts and scripts where order of execution is important - ex: if a script needs a third party library we would include that library before your own script so your script can use the libraries code - so have to use defer. defere guarentees correct order of execution.

//for 3rd party software where order doesnt matter then use Async - You can use different strategies for different scripts - usually a complete web application includes more than just one script
